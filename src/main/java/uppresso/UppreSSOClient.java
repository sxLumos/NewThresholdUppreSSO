package uppresso;


import com.auth0.jwt.interfaces.DecodedJWT;
import org.bouncycastle.math.ec.ECPoint;
import server.idp.Certificate;
import utils.CryptoUtil;

import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.PublicKey;
import java.net.Socket;
import java.util.Base64;

import network.NetworkMessage;

public class UppreSSOClient {
    private final String username;
    private final String password;
    private final UppreSSOIdP idp;
    private String idpHost = "localhost";
    private int idpPort = 9100; // must match UppreSSOIdP.listenPort
    private String rpHost = "localhost";
    private int rpPort = 9101; // must match UppreSSORP.rpListenPort

    public static void main(String[] args) {
        UppreSSOClient client = new UppreSSOClient("shenxin", "123456", null);

        long a = System.currentTimeMillis();
        client.register();
        long b = System.currentTimeMillis();
        System.out.printf("User Register: %d ms\n", b - a);
        for(int i = 0;i < 1;i ++ ){
            client.loginAndRequestToken();
        }
    }

    public UppreSSOClient(String username, String password, UppreSSOIdP idp) {
        this.username = username;
        this.password = password;
        this.idp = idp; // kept for backward compatibility; not used in network mode
    }

    /**
     * Plain Registration Flow:
     * 1. Send username and H(password) to the IdP.
     * 2. Receive and store the secret ID_U generated by the IdP.
     */
    public void register() {
        System.out.println("\n▶️ Client starting registration for user '" + this.username + "'...");
        String hashedPassword = hash(this.password);
        // Send over network to UppreSSO IdP server
        try (Socket socket = new Socket(idpHost, idpPort)) {
            String reqId = "up_reg_" + System.currentTimeMillis();
            java.util.Map<String, Object> data = new java.util.HashMap<>();
            data.put("username", this.username);
            data.put("hashedPassword", hashedPassword);
            NetworkMessage req = new NetworkMessage("UP_REGISTER_USER", reqId, data);
            ObjectOutputStream out = new ObjectOutputStream(socket.getOutputStream());
            out.writeObject(req);
            out.flush();
            ObjectInputStream in = new ObjectInputStream(socket.getInputStream());
            NetworkMessage resp = (NetworkMessage) in.readObject();
            if (resp.getData() == null || !Boolean.TRUE.equals(resp.getData().get("success"))) {
                System.err.println("❌ Registration failed: " + (resp.getData() == null ? "no data" : resp.getData().get("error")));
            }
        } catch (Exception e) {
            System.err.println("❌ Registration network error: " + e.getMessage());
        }
    }

    /**
     * Plain Login and Token Request Flow.
     */
    public void loginAndRequestToken() {
        System.out.println("\n▶️ Client starting login for user '" + this.username + "'...");
        long a = System.currentTimeMillis();
        // Step 1: Obtain RP certificate over network
        Certificate cert_rp = null;
        ECPoint id_rp = null;
        try (Socket socket = new Socket(rpHost, rpPort)) {
            String reqId = "up_rp_cert_" + System.currentTimeMillis();
            java.util.Map<String, Object> data = new java.util.HashMap<>();
            NetworkMessage req = new NetworkMessage("UP_RP_CERT_REQUEST", reqId, data);
            ObjectOutputStream out = new ObjectOutputStream(socket.getOutputStream());
            out.writeObject(req);
            out.flush();
            ObjectInputStream in = new ObjectInputStream(socket.getInputStream());
            NetworkMessage resp = (NetworkMessage) in.readObject();
            if (resp.getData() != null && Boolean.TRUE.equals(resp.getData().get("success"))) {
                String idRpHex = (String) resp.getData().get("identity");
                String sigHex = (String) resp.getData().get("signature");
                String rpHost = (String) resp.getData().get("rpHost");
                String publicKeyBase64 = (String) resp.getData().get("publicKey");
                id_rp = CryptoUtil.decodePointFromHex(idRpHex);
                // REQUIREMENT 1: RP verifies the certificate signature
                String content = idRpHex + ":" + rpHost;
                byte[] signature = CryptoUtil.hexToBytes(sigHex);
                byte[] pkBytes = Base64.getDecoder().decode(publicKeyBase64);
                java.security.spec.X509EncodedKeySpec spec = new java.security.spec.X509EncodedKeySpec(pkBytes);
                java.security.KeyFactory kf = java.security.KeyFactory.getInstance("RSA");
                PublicKey publicKey = kf.generatePublic(spec);
                if (RSAKeyGenerator.verify(content, signature, publicKey)) {
                    System.out.println("✅ RP successfully verified its new certificate from IdP.");
                } else {
                    System.err.println("❌ CRITICAL: RP failed to verify its new certificate. Aborting.");
                }
            } else {
                System.err.println("❌ Failed to fetch RP certificate: " + (resp.getData() == null ? "no data" : resp.getData().get("error")));
                return;
            }
        } catch (Exception e) {
            System.err.println("❌ RP certificate request network error: " + e.getMessage());
            return;
        }
        // Step 2: Build pid_rp and request token over network
        // ECPoint id_rp is obtained from certificate above
        // id_rp already set

        // 2a. Generate blinding factor 't'
        BigInteger t = CryptoUtil.randomScalar();

        // 2b. Calculate the blinded Relying Party ID (PID_RP)
        ECPoint pid_rp = id_rp.multiply(t).normalize();

        // 2c. Send username and PID_RP to the IdP to get the token
        String jwtToken = null;
        try (Socket socket = new Socket(idpHost, idpPort)) {
            String reqId = "up_reqtok_" + System.currentTimeMillis();
            java.util.Map<String, Object> data = new java.util.HashMap<>();
            data.put("username", this.username);
            data.put("pid_rp", CryptoUtil.bytesToHex(pid_rp.getEncoded(true)));
            NetworkMessage req = new NetworkMessage("UP_REQUEST_TOKEN", reqId, data);
            ObjectOutputStream out = new ObjectOutputStream(socket.getOutputStream());
            out.writeObject(req);
            out.flush();
            ObjectInputStream in = new ObjectInputStream(socket.getInputStream());
            NetworkMessage resp = (NetworkMessage) in.readObject();
            if (resp.getData() != null && Boolean.TRUE.equals(resp.getData().get("success"))) {
                jwtToken = (String) resp.getData().get("jwt");
            } else {
                System.err.println("❌ Token request failed: " + (resp.getData() == null ? "no data" : resp.getData().get("error")));
            }
        } catch (Exception e) {
            System.err.println("❌ Token request network error: " + e.getMessage());
        }

        long b = System.currentTimeMillis();
        System.out.printf("Token Request: %d ms\n", b - a);
        a = System.currentTimeMillis();
        if (jwtToken == null) {
            System.err.println("❌ Login failed: Did not receive a token from the IdP.");
            return;
        }
        // REQUIREMENT 3: Delegate token verification to RP
        System.out.println("   - Step 4: Sending token to RP for verification...");
        boolean isTokenValid = verifyTokenAtRP(jwtToken);

        if (!isTokenValid) {
            System.err.println("❌ RP reported that the token is invalid.");
            return;
        }

        System.out.println("✅ RP confirmed token is valid. Login successful!");
        // The rest of the logic (unblinding) can proceed if needed, or you can consider the flow complete.
        // ... (unblinding logic) ...

//        PublicKey publicKey = new RSAKeyGenerator(false).getPublicKey();
//        DecodedJWT verifiedJwt = RSAJWTVerifier.verify(jwtToken, publicKey);

        // 3a. Extract the blinded pid_u from the token
//        String pidUBase64 = verifiedJwt.getClaim("pid_u").asString();
//        byte[] pidUBytes = Base64.getUrlDecoder().decode(pidUBase64);
//        ECPoint blindedPidU = CryptoUtil.EC_SPEC.getCurve().decodePoint(pidUBytes);

        // 3b. Unblind it using the inverse of t
//        BigInteger t_inverse = t.modInverse(CryptoUtil.ORDER);
//        ECPoint final_IDU_IDRP = blindedPidU.multiply(t_inverse).normalize();
        b = System.currentTimeMillis();
        System.out.printf("User Register: %d ms\n", b - a);
//        System.out.println("✅ Login and token validation complete!");
//        System.out.println("   - Final unblinded value [ID_U]ID_RP: " + CryptoUtil.bytesToHex(final_IDU_IDRP.getEncoded(true)));
    }

    private boolean verifyTokenAtRP(String jwtToken) {
        try (Socket socket = new Socket(rpHost, rpPort)) {
            String reqId = "up_rp_verify_tok_" + System.currentTimeMillis();
            java.util.Map<String, Object> data = new java.util.HashMap<>();
            data.put("jwt", jwtToken);

            NetworkMessage req = new NetworkMessage("UP_RP_VERIFY_TOKEN_REQUEST", reqId, data);
            ObjectOutputStream out = new ObjectOutputStream(socket.getOutputStream());
            out.writeObject(req);
            out.flush();

            ObjectInputStream in = new ObjectInputStream(socket.getInputStream());
            NetworkMessage resp = (NetworkMessage) in.readObject();

            return resp.getData() != null && Boolean.TRUE.equals(resp.getData().get("success"));
        } catch (Exception e) {
            System.err.println("❌ Token verification network error: " + e.getMessage());
            return false;
        }
    }

    private String hash(String input) {
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] hash = digest.digest(input.getBytes(StandardCharsets.UTF_8));
            return Base64.getEncoder().encodeToString(hash);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

}
